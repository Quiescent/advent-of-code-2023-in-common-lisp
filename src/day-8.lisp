(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun shadowing-import-from-fset ()
    `(:shadowing-import-from
     :fset
      ,@(let ((symbols nil))
        (do-external-symbols (symbol (find-package 'fset) symbols)
          (push symbol symbols))))))

(defpackage day-8
  (:use :cl :iterate :cl-ppcre :metabang-bind :trivia :trivia.ppcre)
  #.(shadowing-import-from-fset)
  (:shadowing-import-from :arrow-macros :->>)
  (:shadowing-import-from :arrow-macros :->))
(in-package day-8)

(defun parse-line (line)
  (->> (remove #\, line)
    (remove #\()
    (remove #\))
    (remove #\=)
    (split " +")
    (mapcar #'read-from-string)))

(defun read-problem ()
  (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2023-in-common-lisp "src/day-8.in"))
    (labels ((recur (acc)
               (bind ((line (read-line f nil nil)))
                 (if (null line)
                     acc
                     (recur (if (string-equal line "")
                                acc
                                (cons (parse-line line)
                                      acc)))))))
      (cons (read-line f nil nil) (recur nil)))))

(defun to-graph (xs graph)
  (if (null xs)
      graph
      (bind (((start left right) (car xs)))
        (to-graph (cdr xs)
                  (with graph start (cons left right))))))

(defun part-1 ()
  (bind (((instructions . edges) (read-problem))
         (graph (to-graph edges (empty-map)))
         (node (intern "AAA"))
         (end (intern "ZZZ")))
    (iter
      (for idx from 0)
      (when (>= idx (length instructions))
        (setf idx 0))
      (for char = (aref instructions idx))
      (for i from 0)
      (while (not (eq node end)))
      (for (left . right) = (@ graph node))
      (if (char-equal char #\L)
          (setf node left)
          (setf node right))
      (finally (return i)))))

(defun parse-line-2 (line)
  (->> (remove #\, line)
    (remove #\()
    (remove #\))
    (remove #\=)
    (split " +")))

(defun read-problem-2 ()
  (with-open-file (f (asdf:system-relative-pathname :advent-of-code-2023-in-common-lisp "src/day-8.in"))
    (labels ((recur (acc)
               (bind ((line (read-line f nil nil)))
                 (if (null line)
                     acc
                     (recur (if (string-equal line "")
                                acc
                                (cons (parse-line-2 line)
                                      acc)))))))
      (cons (read-line f nil nil) (recur nil)))))

(defun run-one-node-back (node end-node graph instructions idx)
  (iter
    (incf idx)
    (when (>= idx (length instructions))
      (setf idx 0))
    (for char = (aref instructions idx))
    (for i from 0)
    (while (not (eq node end-node)))
    (for (left . right) = (@ graph node))
    (if (char-equal char #\L)
        (setf node left)
        (setf node right))
    (finally (return i))))

(defun run-one-node (start-node graph instructions)
  (bind ((node start-node))
    (iter
      (for idx from 0)
      (when (>= idx (length instructions))
        (setf idx 0))
      (for char = (aref instructions idx))
      (for i from 0)
      (while (not (char-equal (aref node 2) #\Z)))
      (for (left . right) = (@ graph node))
      (if (char-equal char #\L)
          (setf node left)
          (setf node right))
      (finally (return (+ i (run-one-node-back node node graph instructions (1- idx))))))))

(defun part-2 ()
  (bind (((instructions . edges) (read-problem-2))
         (graph (to-graph edges (empty-map)))
         (nodes (remove-if (lambda (node) (not (char-equal (aref node 2) #\A)))
                           (mapcar #'car edges)))
         (cycle-lengths (mapcar (lambda (node) (run-one-node node graph instructions))
                                nodes)))
    (apply #'lcm cycle-lengths)))
